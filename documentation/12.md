<div dir="rtl">

# سوال: تغییر مبنا

## الگوریتم

این مسئله یک مسئله ترکیبیاتی است. ابتدا آن را روی کاغذ حل می‌کنیم.

* اگر
$n$
زوج باشد آنگاه بعد از یک دور کل اعداد زوج حذف می‌شود. اعداد باقی مانده به صورت 
$1 - (2*x)$
خواهند بود.

* اگر 
$n$
فرد باشد بعد از یک دور کل اعداد زوج حذف می‌شود. اگر یک مرحله دیگر ادامه دهیم 
1
هم حذف می‌شود و سپس اعداد باقی مانده به فرم
$1 + (2*x)$
خواهند بود.


در نتیجه باید تابع بازگشتی 
`f(n) = f(n/2) + (n&1 ? 1 : -1)`
را محاسبه کنیم که پایه آن
`f(1) = 1`
می‌باشد.

--- 
## چالش ها
### استک و ساختار بازگشتی:
<br>

در دو ماشین 
MIPS, IBM 360 
به صورت پیش‌فرض ساختار استک و 
push, pop
تعریف نمی‌شود.
در 
MIPS
با استفاده از ماکرو ها دقیقا عملگر های 
push, pop, ret
را پیاده سازی کردیم و با آن تابع بازگشتی زدیم.

در ماشین MIPS
ساختار بازگشتی را به این‌صورت پیاده کردیم.

<div dir="ltr">

```
.macro push (%reg)
    addi $sp, $sp, -4
    sw %reg, 0($sp)
.end_macro

.macro pop (%reg)
    lw %reg, 0($sp)
    addi $sp, $sp, 4
.end_macro

.macro start_call()
    push($ra)
.end_macro

.macro end_call()
    pop($ra)
    jr $ra
.end_macro

.macro call(%label)
    jal %label
.end_macro


my_function: # input in a0 output in v0
    start_call()
    # do the calculations
    end_call()
end_func:    

```

</div>

به طور مشابه در ماشین 
IBM 360
نیز یک حافظه به عنوان استک تعریف کردیم و یک رجیستر را به 
stack pointer
اختصاص دادیم.

</div>
