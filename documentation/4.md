<div dir="rtl">

# سوال: ماشین حساب ساده

## الگوریتم
ایده اصلی در اینجا این است که از گرامر در نظریه زبان ها استفاده کنیم و عبارت را تجریه کنیم.

<div dir="ltr">

E: Any expression

MD: Expression that is not splitted by + or -

CR: Expression that is not splitted at all

N : number

E -> MD + E

E -> MD - E

E -> MD

MD -> MD * CR

MD -> MD / CR

MD -> CR

CR -> (CR)

CR -> N

N -> [0-9]

N -> [0-9]N

<div dir="rtl">

عبارت به صورت یکتا تجزیه می‌شود. برای هر کدام از قسمت ها تابعی می‌نویسیم. به عنوان مثال تابع 
read_cr
تلاش می‌کند تا جایی که امکان 
match
شدن عبارت به 
CR
وجود دارد یکی یکی کاراکتر ها را بخواند .

در نهایت در هر سه ماشین ایده اصلی این است که دو متغیر 
global
در نظر بگیریم. یکی برای آخرین کاراکتری که خوانده ایم و دیگری برای آخرین مقداری 
که 
parse
شده است. 

با فراخوانی تابع
read_expr
پس از پایان اجرای تابع جواب ما در متغیر مربوطه ذخیره می‌شود.

--- 
## چالش ها
### استک و ساختار بازگشتی:
<br>

در دو ماشین 
MIPS, IBM 360 
به صورت پیش‌فرض ساختار استک و 
push, pop
تعریف نمی‌شود.
در 
MIPS
با استفاده از ماکرو ها دقیقا عملگر های 
push, pop, ret
را پیاده سازی کردیم و با آن تابع بازگشتی زدیم.

<br>

### مقدار float:
در ماشین 8086
مقدار float
به صورت پیش‌فرض وجود ندارد. 

ایده این بود که از روش
fixed floating point
استفاده کنیم و به جای نگه داشتن مقدار 
x 
مقدار
10*x
را در رجیستر نگه داری کنیم. 
به اینصورت اعداد اعشاری با دقت یک رقم اعشار داریم.

برای اینکار توابع جمع تفریق ضرب تقسیم را خودمان برای 
fixed floating point
تعریف کردیم.

در ماشین MIPS
مقدار
float
وجود دارد. برای اینکار باید از رجیستر های 
f0, f1, ..., f15
استفاده کردیم که عملیات های جمع و تفریق و ضرب و تقسیم اعشاری روی آن‌ها تعریف شده است.

<br>

### خطایابی:

برای اینکه بتوانیم خطا‌های برنامه را موقع اجرا پیدا کنیم
(division by zero, overflow, ...)
یک 
label
در انتهای کد تغریف کردیم که هر لیبل مربوط به یک خطا است. سپس در هنگامی که آن خطا شناسایی می‌شود به آن لیبل 
jump
می‌کنیم.

<div dir="ltr">

```
start_prog:
    # Main Code
end_prog:

j exit

exit_divide_by_zero:
print_stri("Divide by zero happened")
j exit

exit_overflow:
print_stri("There was an overflow")
j exit

exit_not_valid:
print_stri("The input is invalid")
j exit

exit:
```


</div>

</div>
